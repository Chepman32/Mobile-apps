#!/usr/bin/env python3
"""
scaffold_apps.py
================

Utility for programmatically scaffolding many Expo React-Native projects in their
own directories.  The script expects a JSON manifest describing each app, its
required npm dependencies, and any in-app-purchase (IAP) identifiers you wish
to track.  Only the *name* field is required ‚Äì the others are optional and are
used to pre-populate the generated *package.json*.

Example manifest (save as apps_offline.json):

[
  {
    "name": "TimeCapsule",
    "dependencies": [
      "react-native-sqlite-storage",
      "react-native-biometrics",
      "react-native-mmkv",
      "react-native-share"
    ],
    "iap": [
      "Premium_Capsules",
      "Future_Themes"
    ]
  },
  {
    "name": "DreamDecoder",
    "dependencies": [
      "react-native-ml-kit",
      "react-native-sqlite-storage",
      "react-native-tts",
      "react-native-chart-kit"
    ],
    "iap": [
      "Dream_Symbols",
      "Analysis_Pro"
    ]
  }
]

Save the manifest somewhere in the repository (e.g. *scripts/apps_offline.json*)
and run:

    python scripts/scaffold_apps.py scripts/apps_offline.json

The script will:
  1. Loop over every entry in the JSON array.
  2. Create a directory for the app (skips if it already exists).
  3. Run `npx create-expo-app` to scaffold a blank TypeScript Expo project.
  4. Merge the listed *dependencies* into the generated **package.json** with
     the version set to "latest".
  5. Drop a simple **README.md** into the project root describing the app.

All normal `create-expo-app` output is streamed to the console so you can follow
progress.  To keep the process non-interactive, the `--yes` flag is passed so
Expo doesn‚Äôt pause for user input.

"""
import json
import os
import pathlib
import subprocess
import sys
from typing import List, Dict, Any


def _merge_dependencies(pkg_path: pathlib.Path, extra_deps: List[str]) -> None:
    """Merge *extra_deps* into the given *package.json* file."""

    if not pkg_path.exists():
        print(f"warning: {pkg_path} does not exist ‚Äì skipping dependency merge")
        return

    with pkg_path.open() as fp:
        pkg = json.load(fp)

    deps: Dict[str, Any] = pkg.setdefault("dependencies", {})
    for dep in extra_deps:
        # Do not overwrite a dependency that already specifies a version.
        deps.setdefault(dep, "latest")

    with pkg_path.open("w") as fp:
        json.dump(pkg, fp, indent=2)
        fp.write("\n")  # newline at EOF for sanity


def scaffold_apps(manifest_path: str) -> None:
    manifest_file = pathlib.Path(manifest_path)
    if not manifest_file.exists():
        print(f"Manifest file not found: {manifest_file}", file=sys.stderr)
        sys.exit(1)

    with manifest_file.open() as fp:
        apps = json.load(fp)

    if not isinstance(apps, list):
        print("Manifest JSON must be a list of app definitions", file=sys.stderr)
        sys.exit(1)

    for app in apps:
        name = app.get("name")
        if not name:
            print("Skipping entry without a 'name' field:", app)
            continue

        dir_name = name.strip().replace(" ", "")  # remove spaces just in case
        project_dir = pathlib.Path(dir_name)

        if project_dir.exists():
            print(f"‚ö†Ô∏è  Skipping {dir_name} ‚Äì directory already exists")
            continue

        print(f"üöÄ Creating {dir_name} ‚Ä¶")
        # Initialise a new Expo TypeScript project non-interactively.
        subprocess.run(
            [
                "npx",
                "create-expo-app@latest",
                dir_name,
                "--template",
                "expo-template-blank-typescript",
                "--yes",
            ],
            check=True,
        )

        # Merge any extra dependencies specified in the manifest.
        extra_deps = app.get("dependencies", [])
        if extra_deps:
            _merge_dependencies(project_dir / "package.json", extra_deps)

        # Write a very small README so each folder has at least one descriptor.
        readme = project_dir / "README.md"
        if not readme.exists():
            with readme.open("w") as fp:
                fp.write(f"# {name}\n\nGenerated by `scripts/scaffold_apps.py`.\n")

    print("\n‚úÖ All apps scaffolded ‚Äì commit your changes!")


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python scripts/scaffold_apps.py <manifest.json>", file=sys.stderr)
        sys.exit(1)

    scaffold_apps(sys.argv[1])